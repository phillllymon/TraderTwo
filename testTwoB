const { CREDS } = require("./CREDS");
const { createSimpleDaysArr, dataArrToSymObj, arrAve } = require("./util");
const fs = require("fs");

// NOTE: the longer the time range, the more accuracy!!!!
const startDate = "2025-01-01";
const endDate = "2026-01-01";

const filesToUse = [
    "allSyms",
    "allSymsA",
    "allSymsB",
    "allSymsC",
    "allSymsD",
    "allSymsE",
    "allSymsF",
    "allSymsG"
];

const datesArr = createSimpleDaysArr(startDate, endDate);
// main for general test
const datesToUse = [];
datesArr.forEach((date) => {
    if (readDateData(date)) {
        datesToUse.push(date);
    }
});
console.log(datesToUse);

const numSymsToUse = 5;
const lookBackBig = 100;
const lookBackSmall = 2;

let right = 0;
let wrong = 0;

let upDays = 0;
let downDays = 0;

let amt = 100;
const amts = [amt];
const percents = [];
const qqqPercents = [];

const allSyms = combineAllSymsFiles(filesToUse);

const dayRatios = [];

const codeBook = {};

for (let i = lookBackSmall; i < datesToUse.length; i++) {
    console.log(`date ${i} / ${datesToUse.length}`);
    
    const sampleData = [];
    for (let j = lookBackSmall; j > -1; j--) {
        const thisData = dataArrToSymObj(readDateData(datesToUse[i - j]), "T");
        sampleData.push(thisData);
    }
    
    const commonSyms = [];

    const symArrs = [];
    sampleData.forEach((dayData) => {
        symArrs.push(Object.keys(dayData));
    });

    symArrs[0].forEach((sym) => {
        let useSym = true;
        for (let j = 1; j < symArrs.length; j++) {
            if (!symArrs[j].includes(sym)) {
                useSym = false;
            }
        }
        if (useSym) {
            commonSyms.push(sym);
        }
    });
    
    const todayData = dataArrToSymObj(readDateData(datesToUse[i]), "T");
    const tomorrowData = i < datesToUse.length - 1 ? dataArrToSymObj(readDateData(datesToUse[i + 1]), "T") : false;
    let lastDay = false;
    if (!tomorrowData) {
        lastDay = true;
    }

    const todayRatios = [];
    const symsToUse = [];

    commonSyms.forEach((sym) => {
        // if (todayData[sym] && (lastDay || (tomorrowData && tomorrowData[sym]))) {
        if (todayData[sym]) {
            const codeArr = [];
            for (let j = 1; j < sampleData.length; j++) {
                const thisClose = sampleData[j][sym].c;
                const prevClose = sampleData[j - 1][sym].c;
                const thisVol = sampleData[j][sym].v;
                const prevVol = sampleData[j - 1][sym].v;
                if (thisClose > prevClose) {
                    codeArr.push(1);
                } else {
                    codeArr.push(0);
                }
                // if (thisVol > prevVol) {
                //     codeArr.push(1);
                // } else {
                //     codeArr.push(0);
                // }
            }
            // const codeStr = codeArr.join("-");
            const codeStr = "justOneCode";
            if (codeBook[sym] && codeBook[sym][codeStr]) {
                let score = codeBook[sym][codeStr].up;
                if (codeBook[sym][codeStr].down > 0) {
                    score /= codeBook[sym][codeStr].down;
                }
                if (symsToUse.length < numSymsToUse || score > symsToUse[0].score) {
                    if (true
                        // && score > 1.25
                        && todayData[sym].c > 0.01
                        && todayData[sym].v > 100000
                        && !sym.includes("ZVZZT")
                    ) {
                        symsToUse.push({
                            sym: sym,
                            score: score
                        });
                        symsToUse.sort((a, b) => {
                            if (a.score > b.score) {
                                return 1;
                            } else {
                                return -1;
                            }
                        });
                        while (symsToUse.length > numSymsToUse) {
                            symsToUse.shift();
                        }
                    }
                }
            }


            // add entry to book
            // if (!lastDay) {
            if (!lastDay && tomorrowData[sym]) {
                if (!codeBook[sym]) {
                    codeBook[sym] = {};
                }
                if (!codeBook[sym][codeStr]) {
                    codeBook[sym][codeStr] = {
                        up: 0,
                        down: 0
                    };
                }
                if (tomorrowData[sym].c > 1.05 * tomorrowData[sym].o) {
                    codeBook[sym][codeStr].up += 1;
                }
                if (tomorrowData[sym].c < 1.00 * tomorrowData[sym].o) {
                    codeBook[sym][codeStr].down += 1;
                }
            }
            // end add entry
        }
    });


    // ------------------ finite num method ------------------
    if (lastDay) {
        console.log(`LAST DAY - ${datesToUse[i]}`);
        console.log(symsToUse.map(ele => ele.sym));
    } else {
        symsToUse.map(ele => ele.sym).forEach((sym) => {
            
            let buyPrice = 1;
            let sellPrice = 1;
            if (tomorrowData[sym]) {
                buyPrice = tomorrowData[sym].o;
                sellPrice = tomorrowData[sym].c;
            }
            

            
            const ratio = sellPrice / buyPrice;
            todayRatios.push(ratio);
    
            if (ratio > 1) {
                right += 1;
            }
            if (ratio < 1) {
                wrong += 1;
            }
        });
    }

    // -------------- end finite num method ------------------


    let todayRatio = todayRatios.length > 0 ? arrAve(todayRatios) : 1;
    dayRatios.push(todayRatio);
    

    if (!lastDay) {
        percents.push(todayRatio);
        qqqPercents.push(tomorrowData["QQQ"].c / tomorrowData["QQQ"].o);

        if (todayData["QQQ"].c / todayData["QQQ"].o > 1.004) {
            // todayRatio = 1;
        }
    }

    console.log("syms today: " + todayRatios.length);
    console.log(todayRatio, symsToUse.map(ele => ele.sym));

    const thresholdMs = new Date("2025-06-01").getTime();
    const thisMs = new Date(datesToUse[i]).getTime();
    if (thisMs > thresholdMs) {
        amt *= todayRatio;
        amts.push(amt);
    
        if (todayRatio > 1) {
            upDays += 1;
        }
        if (todayRatio < 1) {
            downDays += 1;
        }
    }
}

console.log("right: " + right);
console.log("wrong: " + wrong);
console.log("-------------------");
console.log("up days: " + upDays);
console.log("down days: " + downDays);
console.log("-------------------");
console.log("ave day ratio: " + arrAve(dayRatios));

amts.forEach((n) => {
    console.log(n);
});
// console.log(amts[amts.length - 1]);

// percents.forEach((n, i) => {
//     if (i > 15) {
//         console.log(arrAve(percents.slice(i - 15, i)));
//     }
// });
// console.log("************");
// console.log("************");
// console.log("*** qqq below ***");
// console.log("************");
// console.log("************");
// qqqPercents.forEach((n, i) => {
//     if (i > 15) {
//         console.log(arrAve(qqqPercents.slice(i - 15, i)));
//     }
// });




function readDateData(date) {
    let answer = false;
    try {
        const dataArr = JSON.parse(fs.readFileSync(`./data/polygonDays/all${date}.txt`));
        answer = dataArr;
    } catch {
        answer = false;
    }
    return answer;
}

function combineAllSymsFiles(filesToUse) {
    const symsObj = {};
    for (let i = 0; i < filesToUse.length; i++) {
        const arr = JSON.parse(fs.readFileSync(`./data/${filesToUse[0]}.txt`));
        arr.forEach((entry) => {
            if (!symsObj[entry.symbol]) {
                symsObj[entry.symbol] = entry;
            } else {
                if (entry.shortable) {
                    symsObj[entry.symbol].shortable = true;
                }
                if (entry.easy_to_borrow) {
                    symsObj[entry.symbol].easy_to_borrow = true;
                }
            }
        });
    }
    return symsObj;
}

function calculateRSI(values) {
    if (!Array.isArray(values) || values.length < 2) {
      throw new Error("Not enough data to calculate RSI");
    }
  
    const period = values.length - 1;
  
    // Step 1: Calculate initial gains and losses over full length
    let gains = 0;
    let losses = 0;
  
    for (let i = 1; i < values.length; i++) {
      const diff = values[i] - values[i - 1];
      if (diff > 0) gains += diff;
      else losses -= diff; // diff is negative, so subtract to add absolute value
    }
  
    // Average gain/loss (over whole sequence)
    const avgGain = gains / period;
    const avgLoss = losses / period;
  
    const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
    const rsi = 100 - 100 / (1 + rs);
  
    return rsi;
}