const { fetchCurrentMarketSnapshot, fetchDaySummaryWholeMarket } = require("./fetchFromPolygon");

/*
    Run this near the end of the day and buy overnight any syms returned
*/

const steadyDays = 4;
// const steadyDays = 5;
const steadyFraction = 0.05;
const dipFraction = 0.15;
const lastTradeTimeThreshold = 5; // minutes
const minPrice = 0.1;
const maxPrice = 5;

const numSymsToTrade = 5;

let nowTime = new Date().getTime();
fetchCurrentMarketSnapshot().then((initialSnapshot) => {
    const symsToTrack = {};
    initialSnapshot.tickers.forEach((symInfo) => {
        const sym = symInfo.ticker;
        const lastTrade = symInfo.lastTrade;
        if (lastTrade) {
            // make sure last trade was recent
            if (true
                && lastTrade.t / 1000000 > nowTime - (60000 * lastTradeTimeThreshold)
                && lastTrade.p > minPrice
                && lastTrade.p < maxPrice
            ) {
                symsToTrack[sym] = {
                    sym: sym,
                    dipPrice: lastTrade.p
                };
            }
        }
    });
    const steadyDates = [];
    const today = new Date().toISOString().slice(0, 10);
    let runner = today;
    while (steadyDates.length < steadyDays) {
        runner = previousNYSEOpenDay(runner);
        steadyDates.push(runner);
    }
    steadyDates.sort((a, b) => {
        if (a > b) {
            return 1;
        } else {
            return -1;
        }
    });
    const candidates = [];
    getMarketDataForMultipleDates(steadyDates).then((dataByDate) => {
        const prices = {};
        dataByDate[steadyDates[0]].forEach((bar) => {
            if (Object.keys(symsToTrack).includes(bar.T)) {
                prices[bar.T] = [bar.c];
            }
        });
        steadyDates.slice(1, steadyDates.length).forEach((date) => {
            dataByDate[date].forEach((bar) => {
                if (prices[bar.T]) {
                    prices[bar.T].push(bar.c);
                }
            });
        });
        Object.keys(prices).forEach((sym) => {
            if (prices[sym].length === steadyDays) {
                const startingPrice = prices[sym][0];
                let steady = true;
                prices[sym].slice(1, prices[sym].length).forEach((laterPrice) => {
                    if (Math.abs(laterPrice - startingPrice) > steadyFraction * startingPrice) {
                        steady = false;
                    }
                });
                if (steady) {
                    const dipPrice = symsToTrack[sym].dipPrice;
                    if (dipPrice < (1 - dipFraction) * startingPrice) {
                        const dipRatio = startingPrice / dipPrice;
                        if (candidates.length < numSymsToTrade || dipRatio > candidates[0].dipRatio) {
                            candidates.push({
                                sym: sym,
                                dipRatio: dipRatio
                            });
                            candidates.sort((a, b) => {
                                if (a.dipRatio > b.dipRatio) {
                                    return 1;
                                } else {
                                    return -1;
                                }
                            });
                            while (candidates.length > numSymsToTrade) {
                                candidates.shift();
                            }
                        }
                    }
                }
            }
        });
        console.log("SYMS TO BUY OVERNIGHT:");
        console.log(candidates.map(ele => ele.sym));
    });
});

function getMarketDataForMultipleDates(dates) {
    return new Promise((resolve) => {
        const answer = {};
        dates.forEach((date) => {
            fetchDaySummaryWholeMarket(date).then((data) => {
                answer[date] = data;
                if (Object.keys(answer).length === dates.length) {
                    resolve(answer);
                }
            });
        });
    });
}

// helper - generated by chatGPT
function previousNYSEOpenDay(dateStr) {
    const d = new Date(dateStr + "T00:00:00Z"); // safe parsing in UTC
  
    // List of NYSE holidays â€” update per year as needed.
    // Format: "YYYY-MM-DD"
    const holidays = new Set([
        "2025-01-01", // New Year's Day
        "2025-01-20", // MLK Jr Day
        "2025-02-17", // Presidents' Day
        "2025-04-18", // Good Friday
        "2025-05-26", // Memorial Day
        "2025-06-19", // Juneteenth
        "2025-07-04", // Independence Day
        "2025-09-01", // Labor Day
        "2025-11-27", // Thanksgiving Day
        "2025-12-25", // Christmas Day
        "2026-01-01", // New Years Day
        "2026-01-19", // MLK Day
        "2026-02-16", // Presidents Day
        "2026-04-03", // Good Friday
        "2026-05-25", // Memorial Day
        "2026-06-19", // Juneteenth
        "2026-07-03", // Independence Day
        "2026-09-07", // Labor Day
        "2026-11-26", // Thanksgiving
        "2026-12-25", // Christmas Day
        // Add other years if desired
    ]);
  
    function format(d) {
        return d.toISOString().slice(0, 10);
    }
  
    // Step back one day, repeatedly until it is an open trading day
    while (true) {
        d.setUTCDate(d.getUTCDate() - 1);
    
        const ymd = format(d);
        const day = d.getUTCDay(); // 0=Sun, 6=Sat
    
        const isWeekend = (day === 0 || day === 6);
        const isHoliday = holidays.has(ymd);
    
        if (!isWeekend && !isHoliday) {
            return ymd;
        }
    }
}